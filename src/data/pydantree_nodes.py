# Generated by pydantree.codegen - DO NOT EDIT
from __future__ import annotations

from typing import List, Optional
from pydantic import BaseModel
from pydantree.core import TSNode

# Registry for runtime node creation
NODE_MAP: dict[str, type[TSNode]] = {}


class EditableMixin:
    """Mixin providing edit operations for tree nodes."""
    
    def insert_child(self, index: int, child: TSNode) -> TSNode:
        """Insert child at index with grammar validation."""
        # TODO: Add grammar validation logic
        new_children = list(self.children)
        new_children.insert(index, child)
        return self.model_copy(update={'children': new_children})

    def replace_child(self, old_child: TSNode, new_child: TSNode) -> TSNode:
        """Replace child with grammar validation."""
        new_children = [
            new_child if c == old_child else c
            for c in self.children
        ]
        return self.model_copy(update={'children': new_children})

    def delete_child(self, child: TSNode) -> TSNode:
        """Delete child with grammar validation."""
        new_children = [c for c in self.children if c != child]
        return self.model_copy(update={'children': new_children})


class CompoundStatementNode(TSNode, EditableMixin):
    """Generated node for _compound_statement."""
    pass

NODE_MAP['_compound_statement'] = CompoundStatementNode

class SimpleStatementNode(TSNode, EditableMixin):
    """Generated node for _simple_statement."""
    pass

NODE_MAP['_simple_statement'] = SimpleStatementNode

class ExpressionNode(TSNode, EditableMixin):
    """Generated node for expression."""
    pass

NODE_MAP['expression'] = ExpressionNode

class ParameterNode(TSNode, EditableMixin):
    """Generated node for parameter."""
    pass

NODE_MAP['parameter'] = ParameterNode

class PatternNode(TSNode, EditableMixin):
    """Generated node for pattern."""
    pass

NODE_MAP['pattern'] = PatternNode

class PrimaryExpressionNode(ExpressionNode, EditableMixin):
    """Generated node for primary_expression."""
    pass

NODE_MAP['primary_expression'] = PrimaryExpressionNode

class AliasedImportNode(TSNode, EditableMixin):
    """Generated node for aliased_import."""
    __match_args__ = ('type_name', 'alias', 'name')

    @property
    def alias(self) -> IdentifierNode:
        """Access alias field."""
        for child in self.children:
            if child.field_name == 'alias':
                return child
        raise ValueError(f'Required field alias not found')

    @property
    def name(self) -> DottedNameNode:
        """Access name field."""
        for child in self.children:
            if child.field_name == 'name':
                return child
        raise ValueError(f'Required field name not found')

NODE_MAP['aliased_import'] = AliasedImportNode

class ArgumentListNode(TSNode, EditableMixin):
    """Generated node for argument_list."""
    pass

NODE_MAP['argument_list'] = ArgumentListNode

class AsPatternNode(ExpressionNode, EditableMixin):
    """Generated node for as_pattern."""
    __match_args__ = ('type_name', 'alias')

    @property
    def alias(self) -> Optional[TSNode]:
        """Access alias field."""
        for child in self.children:
            if child.field_name == 'alias':
                return child
        return None

NODE_MAP['as_pattern'] = AsPatternNode

class AssertStatementNode(SimpleStatementNode, EditableMixin):
    """Generated node for assert_statement."""
    pass

NODE_MAP['assert_statement'] = AssertStatementNode

class AssignmentNode(TSNode, EditableMixin):
    """Generated node for assignment."""
    __match_args__ = ('type_name', 'left', 'right', 'type')

    @property
    def left(self) -> PatternNode | PatternListNode:
        """Access left field."""
        for child in self.children:
            if child.field_name == 'left':
                return child
        raise ValueError(f'Required field left not found')

    @property
    def right(self) -> Optional[AssignmentNode | AugmentedAssignmentNode | ExpressionNode | ExpressionListNode | PatternListNode | YieldTokenNode]:
        """Access right field."""
        for child in self.children:
            if child.field_name == 'right':
                return child
        return None

    @property
    def type(self) -> Optional[TypeTokenNode]:
        """Access type field."""
        for child in self.children:
            if child.field_name == 'type':
                return child
        return None

NODE_MAP['assignment'] = AssignmentNode

class AttributeNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for attribute."""
    __match_args__ = ('type_name', 'attribute', 'object')

    @property
    def attribute(self) -> IdentifierNode:
        """Access attribute field."""
        for child in self.children:
            if child.field_name == 'attribute':
                return child
        raise ValueError(f'Required field attribute not found')

    @property
    def object(self) -> PrimaryExpressionNode:
        """Access object field."""
        for child in self.children:
            if child.field_name == 'object':
                return child
        raise ValueError(f'Required field object not found')

NODE_MAP['attribute'] = AttributeNode

class AugmentedAssignmentNode(TSNode, EditableMixin):
    """Generated node for augmented_assignment."""
    __match_args__ = ('type_name', 'left', 'operator', 'right')

    @property
    def left(self) -> PatternNode | PatternListNode:
        """Access left field."""
        for child in self.children:
            if child.field_name == 'left':
                return child
        raise ValueError(f'Required field left not found')

    @property
    def operator(self) -> ModEqualsTokenNode | AmpersandEqualsTokenNode | PowerEqualsTokenNode | TimesEqualsTokenNode | PlusEqualsTokenNode | MinusEqualsTokenNode | FloorDivEqualsTokenNode | DivideEqualsTokenNode | LeftShiftEqualsTokenNode | RightShiftEqualsTokenNode | AtEqualsTokenNode | CaretEqualsTokenNode | PipeEqualsTokenNode:
        """Access operator field."""
        for child in self.children:
            if child.field_name == 'operator':
                return child
        raise ValueError(f'Required field operator not found')

    @property
    def right(self) -> AssignmentNode | AugmentedAssignmentNode | ExpressionNode | ExpressionListNode | PatternListNode | YieldTokenNode:
        """Access right field."""
        for child in self.children:
            if child.field_name == 'right':
                return child
        raise ValueError(f'Required field right not found')

NODE_MAP['augmented_assignment'] = AugmentedAssignmentNode

class AwaitTokenNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for await."""
    pass

NODE_MAP['await'] = AwaitTokenNode

class BinaryOperatorNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for binary_operator."""
    __match_args__ = ('type_name', 'left', 'operator', 'right')

    @property
    def left(self) -> PrimaryExpressionNode:
        """Access left field."""
        for child in self.children:
            if child.field_name == 'left':
                return child
        raise ValueError(f'Required field left not found')

    @property
    def operator(self) -> PercentTokenNode | AmpersandTokenNode | AsteriskTokenNode | PowerTokenNode | PlusTokenNode | MinusTokenNode | SlashTokenNode | FloorDivTokenNode | LeftShiftTokenNode | RightShiftTokenNode | AtTokenNode | CaretTokenNode | PipeTokenNode:
        """Access operator field."""
        for child in self.children:
            if child.field_name == 'operator':
                return child
        raise ValueError(f'Required field operator not found')

    @property
    def right(self) -> PrimaryExpressionNode:
        """Access right field."""
        for child in self.children:
            if child.field_name == 'right':
                return child
        raise ValueError(f'Required field right not found')

NODE_MAP['binary_operator'] = BinaryOperatorNode

class BlockNode(TSNode, EditableMixin):
    """Generated node for block."""
    __match_args__ = ('type_name', 'alternative')

    @property
    def alternative(self) -> Optional[List[CaseClauseNode]]:
        """Access alternative field."""
        result = []
        for child in self.children:
            if child.field_name == 'alternative':
                result.append(child)
        return result

NODE_MAP['block'] = BlockNode

class BooleanOperatorNode(ExpressionNode, EditableMixin):
    """Generated node for boolean_operator."""
    __match_args__ = ('type_name', 'left', 'operator', 'right')

    @property
    def left(self) -> ExpressionNode:
        """Access left field."""
        for child in self.children:
            if child.field_name == 'left':
                return child
        raise ValueError(f'Required field left not found')

    @property
    def operator(self) -> AndTokenNode | OrTokenNode:
        """Access operator field."""
        for child in self.children:
            if child.field_name == 'operator':
                return child
        raise ValueError(f'Required field operator not found')

    @property
    def right(self) -> ExpressionNode:
        """Access right field."""
        for child in self.children:
            if child.field_name == 'right':
                return child
        raise ValueError(f'Required field right not found')

NODE_MAP['boolean_operator'] = BooleanOperatorNode

class BreakStatementNode(SimpleStatementNode, EditableMixin):
    """Generated node for break_statement."""
    pass

NODE_MAP['break_statement'] = BreakStatementNode

class CallNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for call."""
    __match_args__ = ('type_name', 'arguments', 'function')

    @property
    def arguments(self) -> ArgumentListNode | GeneratorExpressionNode:
        """Access arguments field."""
        for child in self.children:
            if child.field_name == 'arguments':
                return child
        raise ValueError(f'Required field arguments not found')

    @property
    def function(self) -> PrimaryExpressionNode:
        """Access function field."""
        for child in self.children:
            if child.field_name == 'function':
                return child
        raise ValueError(f'Required field function not found')

NODE_MAP['call'] = CallNode

class CaseClauseNode(TSNode, EditableMixin):
    """Generated node for case_clause."""
    __match_args__ = ('type_name', 'consequence', 'guard')

    @property
    def consequence(self) -> BlockNode:
        """Access consequence field."""
        for child in self.children:
            if child.field_name == 'consequence':
                return child
        raise ValueError(f'Required field consequence not found')

    @property
    def guard(self) -> Optional[IfClauseNode]:
        """Access guard field."""
        for child in self.children:
            if child.field_name == 'guard':
                return child
        return None

NODE_MAP['case_clause'] = CaseClauseNode

class CasePatternNode(TSNode, EditableMixin):
    """Generated node for case_pattern."""
    pass

NODE_MAP['case_pattern'] = CasePatternNode

class ChevronNode(TSNode, EditableMixin):
    """Generated node for chevron."""
    pass

NODE_MAP['chevron'] = ChevronNode

class ClassDefinitionNode(CompoundStatementNode, EditableMixin):
    """Generated node for class_definition."""
    __match_args__ = ('type_name', 'body', 'name', 'superclasses', 'type_parameters')

    @property
    def body(self) -> BlockNode:
        """Access body field."""
        for child in self.children:
            if child.field_name == 'body':
                return child
        raise ValueError(f'Required field body not found')

    @property
    def name(self) -> IdentifierNode:
        """Access name field."""
        for child in self.children:
            if child.field_name == 'name':
                return child
        raise ValueError(f'Required field name not found')

    @property
    def superclasses(self) -> Optional[ArgumentListNode]:
        """Access superclasses field."""
        for child in self.children:
            if child.field_name == 'superclasses':
                return child
        return None

    @property
    def type_parameters(self) -> Optional[TypeParameterNode]:
        """Access type_parameters field."""
        for child in self.children:
            if child.field_name == 'type_parameters':
                return child
        return None

NODE_MAP['class_definition'] = ClassDefinitionNode

class ClassPatternNode(TSNode, EditableMixin):
    """Generated node for class_pattern."""
    pass

NODE_MAP['class_pattern'] = ClassPatternNode

class ComparisonOperatorNode(ExpressionNode, EditableMixin):
    """Generated node for comparison_operator."""
    __match_args__ = ('type_name', 'operators')

    @property
    def operators(self) -> List[NotEqualsTokenNode | LessThanTokenNode | LessEqualsTokenNode | NotEqualsAltTokenNode | EqualityTokenNode | GreaterThanTokenNode | GreaterEqualsTokenNode | InTokenNode | IsTokenNode | IsNotTokenNode | NotInTokenNode]:
        """Access operators field."""
        result = []
        for child in self.children:
            if child.field_name == 'operators':
                result.append(child)
        return result

NODE_MAP['comparison_operator'] = ComparisonOperatorNode

class ComplexPatternNode(TSNode, EditableMixin):
    """Generated node for complex_pattern."""
    pass

NODE_MAP['complex_pattern'] = ComplexPatternNode

class ConcatenatedStringNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for concatenated_string."""
    pass

NODE_MAP['concatenated_string'] = ConcatenatedStringNode

class ConditionalExpressionNode(ExpressionNode, EditableMixin):
    """Generated node for conditional_expression."""
    pass

NODE_MAP['conditional_expression'] = ConditionalExpressionNode

class ConstrainedTypeNode(TSNode, EditableMixin):
    """Generated node for constrained_type."""
    pass

NODE_MAP['constrained_type'] = ConstrainedTypeNode

class ContinueStatementNode(SimpleStatementNode, EditableMixin):
    """Generated node for continue_statement."""
    pass

NODE_MAP['continue_statement'] = ContinueStatementNode

class DecoratedDefinitionNode(CompoundStatementNode, EditableMixin):
    """Generated node for decorated_definition."""
    __match_args__ = ('type_name', 'definition')

    @property
    def definition(self) -> ClassDefinitionNode | FunctionDefinitionNode:
        """Access definition field."""
        for child in self.children:
            if child.field_name == 'definition':
                return child
        raise ValueError(f'Required field definition not found')

NODE_MAP['decorated_definition'] = DecoratedDefinitionNode

class DecoratorNode(TSNode, EditableMixin):
    """Generated node for decorator."""
    pass

NODE_MAP['decorator'] = DecoratorNode

class DefaultParameterNode(ParameterNode, EditableMixin):
    """Generated node for default_parameter."""
    __match_args__ = ('type_name', 'name', 'value')

    @property
    def name(self) -> IdentifierNode | TuplePatternNode:
        """Access name field."""
        for child in self.children:
            if child.field_name == 'name':
                return child
        raise ValueError(f'Required field name not found')

    @property
    def value(self) -> ExpressionNode:
        """Access value field."""
        for child in self.children:
            if child.field_name == 'value':
                return child
        raise ValueError(f'Required field value not found')

NODE_MAP['default_parameter'] = DefaultParameterNode

class DeleteStatementNode(SimpleStatementNode, EditableMixin):
    """Generated node for delete_statement."""
    pass

NODE_MAP['delete_statement'] = DeleteStatementNode

class DictPatternNode(TSNode, EditableMixin):
    """Generated node for dict_pattern."""
    __match_args__ = ('type_name', 'key', 'value')

    @property
    def key(self) -> Optional[List[MinusTokenNode | UnderscoreTokenNode | ClassPatternNode | ComplexPatternNode | ConcatenatedStringNode | DictPatternNode | DottedNameNode | FalseNode | FloatNode | IntegerNode | ListPatternNode | NoneNode | SplatPatternNode | StringNode | TrueNode | TuplePatternNode | UnionPatternNode]]:
        """Access key field."""
        result = []
        for child in self.children:
            if child.field_name == 'key':
                result.append(child)
        return result

    @property
    def value(self) -> Optional[List[CasePatternNode]]:
        """Access value field."""
        result = []
        for child in self.children:
            if child.field_name == 'value':
                result.append(child)
        return result

NODE_MAP['dict_pattern'] = DictPatternNode

class DictionaryNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for dictionary."""
    pass

NODE_MAP['dictionary'] = DictionaryNode

class DictionaryComprehensionNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for dictionary_comprehension."""
    __match_args__ = ('type_name', 'body')

    @property
    def body(self) -> PairNode:
        """Access body field."""
        for child in self.children:
            if child.field_name == 'body':
                return child
        raise ValueError(f'Required field body not found')

NODE_MAP['dictionary_comprehension'] = DictionaryComprehensionNode

class DictionarySplatNode(TSNode, EditableMixin):
    """Generated node for dictionary_splat."""
    pass

NODE_MAP['dictionary_splat'] = DictionarySplatNode

class DictionarySplatPatternNode(ParameterNode, EditableMixin):
    """Generated node for dictionary_splat_pattern."""
    pass

NODE_MAP['dictionary_splat_pattern'] = DictionarySplatPatternNode

class DottedNameNode(TSNode, EditableMixin):
    """Generated node for dotted_name."""
    pass

NODE_MAP['dotted_name'] = DottedNameNode

class ElifClauseNode(TSNode, EditableMixin):
    """Generated node for elif_clause."""
    __match_args__ = ('type_name', 'condition', 'consequence')

    @property
    def condition(self) -> ExpressionNode:
        """Access condition field."""
        for child in self.children:
            if child.field_name == 'condition':
                return child
        raise ValueError(f'Required field condition not found')

    @property
    def consequence(self) -> BlockNode:
        """Access consequence field."""
        for child in self.children:
            if child.field_name == 'consequence':
                return child
        raise ValueError(f'Required field consequence not found')

NODE_MAP['elif_clause'] = ElifClauseNode

class ElseClauseNode(TSNode, EditableMixin):
    """Generated node for else_clause."""
    __match_args__ = ('type_name', 'body')

    @property
    def body(self) -> BlockNode:
        """Access body field."""
        for child in self.children:
            if child.field_name == 'body':
                return child
        raise ValueError(f'Required field body not found')

NODE_MAP['else_clause'] = ElseClauseNode

class ExceptClauseNode(TSNode, EditableMixin):
    """Generated node for except_clause."""
    pass

NODE_MAP['except_clause'] = ExceptClauseNode

class ExceptGroupClauseNode(TSNode, EditableMixin):
    """Generated node for except_group_clause."""
    pass

NODE_MAP['except_group_clause'] = ExceptGroupClauseNode

class ExecStatementNode(SimpleStatementNode, EditableMixin):
    """Generated node for exec_statement."""
    __match_args__ = ('type_name', 'code')

    @property
    def code(self) -> IdentifierNode | StringNode:
        """Access code field."""
        for child in self.children:
            if child.field_name == 'code':
                return child
        raise ValueError(f'Required field code not found')

NODE_MAP['exec_statement'] = ExecStatementNode

class ExpressionListNode(TSNode, EditableMixin):
    """Generated node for expression_list."""
    pass

NODE_MAP['expression_list'] = ExpressionListNode

class ExpressionStatementNode(SimpleStatementNode, EditableMixin):
    """Generated node for expression_statement."""
    pass

NODE_MAP['expression_statement'] = ExpressionStatementNode

class FinallyClauseNode(TSNode, EditableMixin):
    """Generated node for finally_clause."""
    pass

NODE_MAP['finally_clause'] = FinallyClauseNode

class ForInClauseNode(TSNode, EditableMixin):
    """Generated node for for_in_clause."""
    __match_args__ = ('type_name', 'left', 'right')

    @property
    def left(self) -> PatternNode | PatternListNode:
        """Access left field."""
        for child in self.children:
            if child.field_name == 'left':
                return child
        raise ValueError(f'Required field left not found')

    @property
    def right(self) -> List[CommaTokenNode | ExpressionNode]:
        """Access right field."""
        result = []
        for child in self.children:
            if child.field_name == 'right':
                result.append(child)
        return result

NODE_MAP['for_in_clause'] = ForInClauseNode

class ForStatementNode(CompoundStatementNode, EditableMixin):
    """Generated node for for_statement."""
    __match_args__ = ('type_name', 'alternative', 'body', 'left', 'right')

    @property
    def alternative(self) -> Optional[ElseClauseNode]:
        """Access alternative field."""
        for child in self.children:
            if child.field_name == 'alternative':
                return child
        return None

    @property
    def body(self) -> BlockNode:
        """Access body field."""
        for child in self.children:
            if child.field_name == 'body':
                return child
        raise ValueError(f'Required field body not found')

    @property
    def left(self) -> PatternNode | PatternListNode:
        """Access left field."""
        for child in self.children:
            if child.field_name == 'left':
                return child
        raise ValueError(f'Required field left not found')

    @property
    def right(self) -> ExpressionNode | ExpressionListNode:
        """Access right field."""
        for child in self.children:
            if child.field_name == 'right':
                return child
        raise ValueError(f'Required field right not found')

NODE_MAP['for_statement'] = ForStatementNode

class FormatExpressionNode(TSNode, EditableMixin):
    """Generated node for format_expression."""
    __match_args__ = ('type_name', 'expression', 'format_specifier', 'type_conversion')

    @property
    def expression(self) -> ExpressionNode | ExpressionListNode | PatternListNode | YieldTokenNode:
        """Access expression field."""
        for child in self.children:
            if child.field_name == 'expression':
                return child
        raise ValueError(f'Required field expression not found')

    @property
    def format_specifier(self) -> Optional[FormatSpecifierNode]:
        """Access format_specifier field."""
        for child in self.children:
            if child.field_name == 'format_specifier':
                return child
        return None

    @property
    def type_conversion(self) -> Optional[TypeConversionNode]:
        """Access type_conversion field."""
        for child in self.children:
            if child.field_name == 'type_conversion':
                return child
        return None

NODE_MAP['format_expression'] = FormatExpressionNode

class FormatSpecifierNode(TSNode, EditableMixin):
    """Generated node for format_specifier."""
    pass

NODE_MAP['format_specifier'] = FormatSpecifierNode

class FunctionDefinitionNode(CompoundStatementNode, EditableMixin):
    """Generated node for function_definition."""
    __match_args__ = ('type_name', 'body', 'name', 'parameters', 'return_type', 'type_parameters')

    @property
    def body(self) -> BlockNode:
        """Access body field."""
        for child in self.children:
            if child.field_name == 'body':
                return child
        raise ValueError(f'Required field body not found')

    @property
    def name(self) -> IdentifierNode:
        """Access name field."""
        for child in self.children:
            if child.field_name == 'name':
                return child
        raise ValueError(f'Required field name not found')

    @property
    def parameters(self) -> ParametersNode:
        """Access parameters field."""
        for child in self.children:
            if child.field_name == 'parameters':
                return child
        raise ValueError(f'Required field parameters not found')

    @property
    def return_type(self) -> Optional[TypeTokenNode]:
        """Access return_type field."""
        for child in self.children:
            if child.field_name == 'return_type':
                return child
        return None

    @property
    def type_parameters(self) -> Optional[TypeParameterNode]:
        """Access type_parameters field."""
        for child in self.children:
            if child.field_name == 'type_parameters':
                return child
        return None

NODE_MAP['function_definition'] = FunctionDefinitionNode

class FutureImportStatementNode(SimpleStatementNode, EditableMixin):
    """Generated node for future_import_statement."""
    __match_args__ = ('type_name', 'name')

    @property
    def name(self) -> List[AliasedImportNode | DottedNameNode]:
        """Access name field."""
        result = []
        for child in self.children:
            if child.field_name == 'name':
                result.append(child)
        return result

NODE_MAP['future_import_statement'] = FutureImportStatementNode

class GeneratorExpressionNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for generator_expression."""
    __match_args__ = ('type_name', 'body')

    @property
    def body(self) -> ExpressionNode:
        """Access body field."""
        for child in self.children:
            if child.field_name == 'body':
                return child
        raise ValueError(f'Required field body not found')

NODE_MAP['generator_expression'] = GeneratorExpressionNode

class GenericTypeNode(TSNode, EditableMixin):
    """Generated node for generic_type."""
    pass

NODE_MAP['generic_type'] = GenericTypeNode

class GlobalStatementNode(SimpleStatementNode, EditableMixin):
    """Generated node for global_statement."""
    pass

NODE_MAP['global_statement'] = GlobalStatementNode

class IfClauseNode(TSNode, EditableMixin):
    """Generated node for if_clause."""
    pass

NODE_MAP['if_clause'] = IfClauseNode

class IfStatementNode(CompoundStatementNode, EditableMixin):
    """Generated node for if_statement."""
    __match_args__ = ('type_name', 'alternative', 'condition', 'consequence')

    @property
    def alternative(self) -> Optional[List[ElifClauseNode | ElseClauseNode]]:
        """Access alternative field."""
        result = []
        for child in self.children:
            if child.field_name == 'alternative':
                result.append(child)
        return result

    @property
    def condition(self) -> ExpressionNode:
        """Access condition field."""
        for child in self.children:
            if child.field_name == 'condition':
                return child
        raise ValueError(f'Required field condition not found')

    @property
    def consequence(self) -> BlockNode:
        """Access consequence field."""
        for child in self.children:
            if child.field_name == 'consequence':
                return child
        raise ValueError(f'Required field consequence not found')

NODE_MAP['if_statement'] = IfStatementNode

class ImportFromStatementNode(SimpleStatementNode, EditableMixin):
    """Generated node for import_from_statement."""
    __match_args__ = ('type_name', 'module_name', 'name')

    @property
    def module_name(self) -> DottedNameNode | RelativeImportNode:
        """Access module_name field."""
        for child in self.children:
            if child.field_name == 'module_name':
                return child
        raise ValueError(f'Required field module_name not found')

    @property
    def name(self) -> Optional[List[AliasedImportNode | DottedNameNode]]:
        """Access name field."""
        result = []
        for child in self.children:
            if child.field_name == 'name':
                result.append(child)
        return result

NODE_MAP['import_from_statement'] = ImportFromStatementNode

class ImportPrefixNode(TSNode, EditableMixin):
    """Generated node for import_prefix."""
    pass

NODE_MAP['import_prefix'] = ImportPrefixNode

class ImportStatementNode(SimpleStatementNode, EditableMixin):
    """Generated node for import_statement."""
    __match_args__ = ('type_name', 'name')

    @property
    def name(self) -> List[AliasedImportNode | DottedNameNode]:
        """Access name field."""
        result = []
        for child in self.children:
            if child.field_name == 'name':
                result.append(child)
        return result

NODE_MAP['import_statement'] = ImportStatementNode

class InterpolationNode(TSNode, EditableMixin):
    """Generated node for interpolation."""
    __match_args__ = ('type_name', 'expression', 'format_specifier', 'type_conversion')

    @property
    def expression(self) -> ExpressionNode | ExpressionListNode | PatternListNode | YieldTokenNode:
        """Access expression field."""
        for child in self.children:
            if child.field_name == 'expression':
                return child
        raise ValueError(f'Required field expression not found')

    @property
    def format_specifier(self) -> Optional[FormatSpecifierNode]:
        """Access format_specifier field."""
        for child in self.children:
            if child.field_name == 'format_specifier':
                return child
        return None

    @property
    def type_conversion(self) -> Optional[TypeConversionNode]:
        """Access type_conversion field."""
        for child in self.children:
            if child.field_name == 'type_conversion':
                return child
        return None

NODE_MAP['interpolation'] = InterpolationNode

class KeywordArgumentNode(TSNode, EditableMixin):
    """Generated node for keyword_argument."""
    __match_args__ = ('type_name', 'name', 'value')

    @property
    def name(self) -> IdentifierNode:
        """Access name field."""
        for child in self.children:
            if child.field_name == 'name':
                return child
        raise ValueError(f'Required field name not found')

    @property
    def value(self) -> ExpressionNode:
        """Access value field."""
        for child in self.children:
            if child.field_name == 'value':
                return child
        raise ValueError(f'Required field value not found')

NODE_MAP['keyword_argument'] = KeywordArgumentNode

class KeywordPatternNode(TSNode, EditableMixin):
    """Generated node for keyword_pattern."""
    pass

NODE_MAP['keyword_pattern'] = KeywordPatternNode

class KeywordSeparatorNode(ParameterNode, EditableMixin):
    """Generated node for keyword_separator."""
    pass

NODE_MAP['keyword_separator'] = KeywordSeparatorNode

class LambdaTokenNode(ExpressionNode, EditableMixin):
    """Generated node for lambda."""
    pass

NODE_MAP['lambda'] = LambdaTokenNode

class LambdaParametersNode(TSNode, EditableMixin):
    """Generated node for lambda_parameters."""
    pass

NODE_MAP['lambda_parameters'] = LambdaParametersNode

class ListNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for list."""
    pass

NODE_MAP['list'] = ListNode

class ListComprehensionNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for list_comprehension."""
    __match_args__ = ('type_name', 'body')

    @property
    def body(self) -> ExpressionNode:
        """Access body field."""
        for child in self.children:
            if child.field_name == 'body':
                return child
        raise ValueError(f'Required field body not found')

NODE_MAP['list_comprehension'] = ListComprehensionNode

class ListPatternNode(PatternNode, EditableMixin):
    """Generated node for list_pattern."""
    pass

NODE_MAP['list_pattern'] = ListPatternNode

class ListSplatNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for list_splat."""
    pass

NODE_MAP['list_splat'] = ListSplatNode

class ListSplatPatternNode(PatternNode, EditableMixin):
    """Generated node for list_splat_pattern."""
    pass

NODE_MAP['list_splat_pattern'] = ListSplatPatternNode

class MatchStatementNode(CompoundStatementNode, EditableMixin):
    """Generated node for match_statement."""
    __match_args__ = ('type_name', 'body', 'subject')

    @property
    def body(self) -> BlockNode:
        """Access body field."""
        for child in self.children:
            if child.field_name == 'body':
                return child
        raise ValueError(f'Required field body not found')

    @property
    def subject(self) -> List[ExpressionNode]:
        """Access subject field."""
        result = []
        for child in self.children:
            if child.field_name == 'subject':
                result.append(child)
        return result

NODE_MAP['match_statement'] = MatchStatementNode

class MemberTypeNode(TSNode, EditableMixin):
    """Generated node for member_type."""
    pass

NODE_MAP['member_type'] = MemberTypeNode

class ModuleNode(TSNode, EditableMixin):
    """Generated node for module."""
    pass

NODE_MAP['module'] = ModuleNode

class NamedExpressionNode(ExpressionNode, EditableMixin):
    """Generated node for named_expression."""
    __match_args__ = ('type_name', 'name', 'value')

    @property
    def name(self) -> IdentifierNode:
        """Access name field."""
        for child in self.children:
            if child.field_name == 'name':
                return child
        raise ValueError(f'Required field name not found')

    @property
    def value(self) -> ExpressionNode:
        """Access value field."""
        for child in self.children:
            if child.field_name == 'value':
                return child
        raise ValueError(f'Required field value not found')

NODE_MAP['named_expression'] = NamedExpressionNode

class NonlocalStatementNode(SimpleStatementNode, EditableMixin):
    """Generated node for nonlocal_statement."""
    pass

NODE_MAP['nonlocal_statement'] = NonlocalStatementNode

class NotOperatorNode(ExpressionNode, EditableMixin):
    """Generated node for not_operator."""
    __match_args__ = ('type_name', 'argument')

    @property
    def argument(self) -> ExpressionNode:
        """Access argument field."""
        for child in self.children:
            if child.field_name == 'argument':
                return child
        raise ValueError(f'Required field argument not found')

NODE_MAP['not_operator'] = NotOperatorNode

class PairNode(TSNode, EditableMixin):
    """Generated node for pair."""
    __match_args__ = ('type_name', 'key', 'value')

    @property
    def key(self) -> ExpressionNode:
        """Access key field."""
        for child in self.children:
            if child.field_name == 'key':
                return child
        raise ValueError(f'Required field key not found')

    @property
    def value(self) -> ExpressionNode:
        """Access value field."""
        for child in self.children:
            if child.field_name == 'value':
                return child
        raise ValueError(f'Required field value not found')

NODE_MAP['pair'] = PairNode

class ParametersNode(TSNode, EditableMixin):
    """Generated node for parameters."""
    pass

NODE_MAP['parameters'] = ParametersNode

class ParenthesizedExpressionNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for parenthesized_expression."""
    pass

NODE_MAP['parenthesized_expression'] = ParenthesizedExpressionNode

class ParenthesizedListSplatNode(TSNode, EditableMixin):
    """Generated node for parenthesized_list_splat."""
    pass

NODE_MAP['parenthesized_list_splat'] = ParenthesizedListSplatNode

class PassStatementNode(SimpleStatementNode, EditableMixin):
    """Generated node for pass_statement."""
    pass

NODE_MAP['pass_statement'] = PassStatementNode

class PatternListNode(TSNode, EditableMixin):
    """Generated node for pattern_list."""
    pass

NODE_MAP['pattern_list'] = PatternListNode

class PositionalSeparatorNode(ParameterNode, EditableMixin):
    """Generated node for positional_separator."""
    pass

NODE_MAP['positional_separator'] = PositionalSeparatorNode

class PrintStatementNode(SimpleStatementNode, EditableMixin):
    """Generated node for print_statement."""
    __match_args__ = ('type_name', 'argument')

    @property
    def argument(self) -> Optional[List[ExpressionNode]]:
        """Access argument field."""
        result = []
        for child in self.children:
            if child.field_name == 'argument':
                result.append(child)
        return result

NODE_MAP['print_statement'] = PrintStatementNode

class RaiseStatementNode(SimpleStatementNode, EditableMixin):
    """Generated node for raise_statement."""
    __match_args__ = ('type_name', 'cause')

    @property
    def cause(self) -> Optional[ExpressionNode]:
        """Access cause field."""
        for child in self.children:
            if child.field_name == 'cause':
                return child
        return None

NODE_MAP['raise_statement'] = RaiseStatementNode

class RelativeImportNode(TSNode, EditableMixin):
    """Generated node for relative_import."""
    pass

NODE_MAP['relative_import'] = RelativeImportNode

class ReturnStatementNode(SimpleStatementNode, EditableMixin):
    """Generated node for return_statement."""
    pass

NODE_MAP['return_statement'] = ReturnStatementNode

class SetNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for set."""
    pass

NODE_MAP['set'] = SetNode

class SetComprehensionNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for set_comprehension."""
    __match_args__ = ('type_name', 'body')

    @property
    def body(self) -> ExpressionNode:
        """Access body field."""
        for child in self.children:
            if child.field_name == 'body':
                return child
        raise ValueError(f'Required field body not found')

NODE_MAP['set_comprehension'] = SetComprehensionNode

class SliceNode(TSNode, EditableMixin):
    """Generated node for slice."""
    pass

NODE_MAP['slice'] = SliceNode

class SplatPatternNode(TSNode, EditableMixin):
    """Generated node for splat_pattern."""
    pass

NODE_MAP['splat_pattern'] = SplatPatternNode

class SplatTypeNode(TSNode, EditableMixin):
    """Generated node for splat_type."""
    pass

NODE_MAP['splat_type'] = SplatTypeNode

class StringNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for string."""
    pass

NODE_MAP['string'] = StringNode

class StringContentNode(TSNode, EditableMixin):
    """Generated node for string_content."""
    pass

NODE_MAP['string_content'] = StringContentNode

class SubscriptNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for subscript."""
    __match_args__ = ('type_name', 'subscript', 'value')

    @property
    def subscript(self) -> List[ExpressionNode | SliceNode]:
        """Access subscript field."""
        result = []
        for child in self.children:
            if child.field_name == 'subscript':
                result.append(child)
        return result

    @property
    def value(self) -> PrimaryExpressionNode:
        """Access value field."""
        for child in self.children:
            if child.field_name == 'value':
                return child
        raise ValueError(f'Required field value not found')

NODE_MAP['subscript'] = SubscriptNode

class TryStatementNode(CompoundStatementNode, EditableMixin):
    """Generated node for try_statement."""
    __match_args__ = ('type_name', 'body')

    @property
    def body(self) -> BlockNode:
        """Access body field."""
        for child in self.children:
            if child.field_name == 'body':
                return child
        raise ValueError(f'Required field body not found')

NODE_MAP['try_statement'] = TryStatementNode

class TupleNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for tuple."""
    pass

NODE_MAP['tuple'] = TupleNode

class TuplePatternNode(PatternNode, EditableMixin):
    """Generated node for tuple_pattern."""
    pass

NODE_MAP['tuple_pattern'] = TuplePatternNode

class TypeTokenNode(TSNode, EditableMixin):
    """Generated node for type."""
    pass

NODE_MAP['type'] = TypeTokenNode

class TypeAliasStatementNode(SimpleStatementNode, EditableMixin):
    """Generated node for type_alias_statement."""
    pass

NODE_MAP['type_alias_statement'] = TypeAliasStatementNode

class TypeParameterNode(TSNode, EditableMixin):
    """Generated node for type_parameter."""
    pass

NODE_MAP['type_parameter'] = TypeParameterNode

class TypedDefaultParameterNode(ParameterNode, EditableMixin):
    """Generated node for typed_default_parameter."""
    __match_args__ = ('type_name', 'name', 'type', 'value')

    @property
    def name(self) -> IdentifierNode:
        """Access name field."""
        for child in self.children:
            if child.field_name == 'name':
                return child
        raise ValueError(f'Required field name not found')

    @property
    def type(self) -> TypeTokenNode:
        """Access type field."""
        for child in self.children:
            if child.field_name == 'type':
                return child
        raise ValueError(f'Required field type not found')

    @property
    def value(self) -> ExpressionNode:
        """Access value field."""
        for child in self.children:
            if child.field_name == 'value':
                return child
        raise ValueError(f'Required field value not found')

NODE_MAP['typed_default_parameter'] = TypedDefaultParameterNode

class TypedParameterNode(ParameterNode, EditableMixin):
    """Generated node for typed_parameter."""
    __match_args__ = ('type_name', 'type')

    @property
    def type(self) -> TypeTokenNode:
        """Access type field."""
        for child in self.children:
            if child.field_name == 'type':
                return child
        raise ValueError(f'Required field type not found')

NODE_MAP['typed_parameter'] = TypedParameterNode

class UnaryOperatorNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for unary_operator."""
    __match_args__ = ('type_name', 'argument', 'operator')

    @property
    def argument(self) -> PrimaryExpressionNode:
        """Access argument field."""
        for child in self.children:
            if child.field_name == 'argument':
                return child
        raise ValueError(f'Required field argument not found')

    @property
    def operator(self) -> PlusTokenNode | MinusTokenNode | TildeTokenNode:
        """Access operator field."""
        for child in self.children:
            if child.field_name == 'operator':
                return child
        raise ValueError(f'Required field operator not found')

NODE_MAP['unary_operator'] = UnaryOperatorNode

class UnionPatternNode(TSNode, EditableMixin):
    """Generated node for union_pattern."""
    pass

NODE_MAP['union_pattern'] = UnionPatternNode

class UnionTypeNode(TSNode, EditableMixin):
    """Generated node for union_type."""
    pass

NODE_MAP['union_type'] = UnionTypeNode

class WhileStatementNode(CompoundStatementNode, EditableMixin):
    """Generated node for while_statement."""
    __match_args__ = ('type_name', 'alternative', 'body', 'condition')

    @property
    def alternative(self) -> Optional[ElseClauseNode]:
        """Access alternative field."""
        for child in self.children:
            if child.field_name == 'alternative':
                return child
        return None

    @property
    def body(self) -> BlockNode:
        """Access body field."""
        for child in self.children:
            if child.field_name == 'body':
                return child
        raise ValueError(f'Required field body not found')

    @property
    def condition(self) -> ExpressionNode:
        """Access condition field."""
        for child in self.children:
            if child.field_name == 'condition':
                return child
        raise ValueError(f'Required field condition not found')

NODE_MAP['while_statement'] = WhileStatementNode

class WildcardImportNode(TSNode, EditableMixin):
    """Generated node for wildcard_import."""
    pass

NODE_MAP['wildcard_import'] = WildcardImportNode

class WithClauseNode(TSNode, EditableMixin):
    """Generated node for with_clause."""
    pass

NODE_MAP['with_clause'] = WithClauseNode

class WithItemNode(TSNode, EditableMixin):
    """Generated node for with_item."""
    __match_args__ = ('type_name', 'value')

    @property
    def value(self) -> ExpressionNode:
        """Access value field."""
        for child in self.children:
            if child.field_name == 'value':
                return child
        raise ValueError(f'Required field value not found')

NODE_MAP['with_item'] = WithItemNode

class WithStatementNode(CompoundStatementNode, EditableMixin):
    """Generated node for with_statement."""
    __match_args__ = ('type_name', 'body')

    @property
    def body(self) -> BlockNode:
        """Access body field."""
        for child in self.children:
            if child.field_name == 'body':
                return child
        raise ValueError(f'Required field body not found')

NODE_MAP['with_statement'] = WithStatementNode

class YieldTokenNode(TSNode, EditableMixin):
    """Generated node for yield."""
    pass

NODE_MAP['yield'] = YieldTokenNode

class NotEqualsTokenNode(TSNode, EditableMixin):
    """Generated node for !=."""
    pass

NODE_MAP['!='] = NotEqualsTokenNode

class PercentTokenNode(TSNode, EditableMixin):
    """Generated node for %."""
    pass

NODE_MAP['%'] = PercentTokenNode

class ModEqualsTokenNode(TSNode, EditableMixin):
    """Generated node for %=."""
    pass

NODE_MAP['%='] = ModEqualsTokenNode

class AmpersandTokenNode(TSNode, EditableMixin):
    """Generated node for &."""
    pass

NODE_MAP['&'] = AmpersandTokenNode

class AmpersandEqualsTokenNode(TSNode, EditableMixin):
    """Generated node for &=."""
    pass

NODE_MAP['&='] = AmpersandEqualsTokenNode

class LeftParenTokenNode(TSNode, EditableMixin):
    """Generated node for (."""
    pass

NODE_MAP['('] = LeftParenTokenNode

class RightParenTokenNode(TSNode, EditableMixin):
    """Generated node for )."""
    pass

NODE_MAP[')'] = RightParenTokenNode

class AsteriskTokenNode(TSNode, EditableMixin):
    """Generated node for *."""
    pass

NODE_MAP['*'] = AsteriskTokenNode

class PowerTokenNode(TSNode, EditableMixin):
    """Generated node for **."""
    pass

NODE_MAP['**'] = PowerTokenNode

class PowerEqualsTokenNode(TSNode, EditableMixin):
    """Generated node for **=."""
    pass

NODE_MAP['**='] = PowerEqualsTokenNode

class TimesEqualsTokenNode(TSNode, EditableMixin):
    """Generated node for *=."""
    pass

NODE_MAP['*='] = TimesEqualsTokenNode

class PlusTokenNode(TSNode, EditableMixin):
    """Generated node for +."""
    pass

NODE_MAP['+'] = PlusTokenNode

class PlusEqualsTokenNode(TSNode, EditableMixin):
    """Generated node for +=."""
    pass

NODE_MAP['+='] = PlusEqualsTokenNode

class CommaTokenNode(TSNode, EditableMixin):
    """Generated node for ,."""
    pass

NODE_MAP[','] = CommaTokenNode

class MinusTokenNode(TSNode, EditableMixin):
    """Generated node for -."""
    pass

NODE_MAP['-'] = MinusTokenNode

class MinusEqualsTokenNode(TSNode, EditableMixin):
    """Generated node for -=."""
    pass

NODE_MAP['-='] = MinusEqualsTokenNode

class ArrowTokenNode(TSNode, EditableMixin):
    """Generated node for ->."""
    pass

NODE_MAP['->'] = ArrowTokenNode

class DotTokenNode(TSNode, EditableMixin):
    """Generated node for .."""
    pass

NODE_MAP['.'] = DotTokenNode

class SlashTokenNode(TSNode, EditableMixin):
    """Generated node for /."""
    pass

NODE_MAP['/'] = SlashTokenNode

class FloorDivTokenNode(TSNode, EditableMixin):
    """Generated node for //."""
    pass

NODE_MAP['//'] = FloorDivTokenNode

class FloorDivEqualsTokenNode(TSNode, EditableMixin):
    """Generated node for //=."""
    pass

NODE_MAP['//='] = FloorDivEqualsTokenNode

class DivideEqualsTokenNode(TSNode, EditableMixin):
    """Generated node for /=."""
    pass

NODE_MAP['/='] = DivideEqualsTokenNode

class ColonTokenNode(TSNode, EditableMixin):
    """Generated node for :."""
    pass

NODE_MAP[':'] = ColonTokenNode

class WalrusTokenNode(TSNode, EditableMixin):
    """Generated node for :=."""
    pass

NODE_MAP[':='] = WalrusTokenNode

class SemicolonTokenNode(TSNode, EditableMixin):
    """Generated node for ;."""
    pass

NODE_MAP[';'] = SemicolonTokenNode

class LessThanTokenNode(TSNode, EditableMixin):
    """Generated node for <."""
    pass

NODE_MAP['<'] = LessThanTokenNode

class LeftShiftTokenNode(TSNode, EditableMixin):
    """Generated node for <<."""
    pass

NODE_MAP['<<'] = LeftShiftTokenNode

class LeftShiftEqualsTokenNode(TSNode, EditableMixin):
    """Generated node for <<=."""
    pass

NODE_MAP['<<='] = LeftShiftEqualsTokenNode

class LessEqualsTokenNode(TSNode, EditableMixin):
    """Generated node for <=."""
    pass

NODE_MAP['<='] = LessEqualsTokenNode

class NotEqualsAltTokenNode(TSNode, EditableMixin):
    """Generated node for <>."""
    pass

NODE_MAP['<>'] = NotEqualsAltTokenNode

class EqualsTokenNode(TSNode, EditableMixin):
    """Generated node for =."""
    pass

NODE_MAP['='] = EqualsTokenNode

class EqualityTokenNode(TSNode, EditableMixin):
    """Generated node for ==."""
    pass

NODE_MAP['=='] = EqualityTokenNode

class GreaterThanTokenNode(TSNode, EditableMixin):
    """Generated node for >."""
    pass

NODE_MAP['>'] = GreaterThanTokenNode

class GreaterEqualsTokenNode(TSNode, EditableMixin):
    """Generated node for >=."""
    pass

NODE_MAP['>='] = GreaterEqualsTokenNode

class RightShiftTokenNode(TSNode, EditableMixin):
    """Generated node for >>."""
    pass

NODE_MAP['>>'] = RightShiftTokenNode

class RightShiftEqualsTokenNode(TSNode, EditableMixin):
    """Generated node for >>=."""
    pass

NODE_MAP['>>='] = RightShiftEqualsTokenNode

class AtTokenNode(TSNode, EditableMixin):
    """Generated node for @."""
    pass

NODE_MAP['@'] = AtTokenNode

class AtEqualsTokenNode(TSNode, EditableMixin):
    """Generated node for @=."""
    pass

NODE_MAP['@='] = AtEqualsTokenNode

class LeftBracketTokenNode(TSNode, EditableMixin):
    """Generated node for [."""
    pass

NODE_MAP['['] = LeftBracketTokenNode

class BackslashTokenNode(TSNode, EditableMixin):
    """Generated node for \."""
    pass

NODE_MAP['\\'] = BackslashTokenNode

class RightBracketTokenNode(TSNode, EditableMixin):
    """Generated node for ]."""
    pass

NODE_MAP[']'] = RightBracketTokenNode

class CaretTokenNode(TSNode, EditableMixin):
    """Generated node for ^."""
    pass

NODE_MAP['^'] = CaretTokenNode

class CaretEqualsTokenNode(TSNode, EditableMixin):
    """Generated node for ^=."""
    pass

NODE_MAP['^='] = CaretEqualsTokenNode

class UnderscoreTokenNode(TSNode, EditableMixin):
    """Generated node for _."""
    pass

NODE_MAP['_'] = UnderscoreTokenNode

class FutureTokenNode(TSNode, EditableMixin):
    """Generated node for __future__."""
    pass

NODE_MAP['__future__'] = FutureTokenNode

class AndTokenNode(TSNode, EditableMixin):
    """Generated node for and."""
    pass

NODE_MAP['and'] = AndTokenNode

class AsTokenNode(TSNode, EditableMixin):
    """Generated node for as."""
    pass

NODE_MAP['as'] = AsTokenNode

class AssertTokenNode(TSNode, EditableMixin):
    """Generated node for assert."""
    pass

NODE_MAP['assert'] = AssertTokenNode

class AsyncTokenNode(TSNode, EditableMixin):
    """Generated node for async."""
    pass

NODE_MAP['async'] = AsyncTokenNode

class BreakTokenNode(TSNode, EditableMixin):
    """Generated node for break."""
    pass

NODE_MAP['break'] = BreakTokenNode

class CaseTokenNode(TSNode, EditableMixin):
    """Generated node for case."""
    pass

NODE_MAP['case'] = CaseTokenNode

class ClassTokenNode(TSNode, EditableMixin):
    """Generated node for class."""
    pass

NODE_MAP['class'] = ClassTokenNode

class CommentNode(TSNode, EditableMixin):
    """Generated node for comment."""
    pass

NODE_MAP['comment'] = CommentNode

class ContinueTokenNode(TSNode, EditableMixin):
    """Generated node for continue."""
    pass

NODE_MAP['continue'] = ContinueTokenNode

class DefTokenNode(TSNode, EditableMixin):
    """Generated node for def."""
    pass

NODE_MAP['def'] = DefTokenNode

class DelTokenNode(TSNode, EditableMixin):
    """Generated node for del."""
    pass

NODE_MAP['del'] = DelTokenNode

class ElifTokenNode(TSNode, EditableMixin):
    """Generated node for elif."""
    pass

NODE_MAP['elif'] = ElifTokenNode

class EllipsisNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for ellipsis."""
    pass

NODE_MAP['ellipsis'] = EllipsisNode

class ElseTokenNode(TSNode, EditableMixin):
    """Generated node for else."""
    pass

NODE_MAP['else'] = ElseTokenNode

class EscapeInterpolationNode(TSNode, EditableMixin):
    """Generated node for escape_interpolation."""
    pass

NODE_MAP['escape_interpolation'] = EscapeInterpolationNode

class EscapeSequenceNode(TSNode, EditableMixin):
    """Generated node for escape_sequence."""
    pass

NODE_MAP['escape_sequence'] = EscapeSequenceNode

class ExceptTokenNode(TSNode, EditableMixin):
    """Generated node for except."""
    pass

NODE_MAP['except'] = ExceptTokenNode

class ExceptStarTokenNode(TSNode, EditableMixin):
    """Generated node for except*."""
    pass

NODE_MAP['except*'] = ExceptStarTokenNode

class ExecTokenNode(TSNode, EditableMixin):
    """Generated node for exec."""
    pass

NODE_MAP['exec'] = ExecTokenNode

class FalseNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for false."""
    pass

NODE_MAP['false'] = FalseNode

class FinallyTokenNode(TSNode, EditableMixin):
    """Generated node for finally."""
    pass

NODE_MAP['finally'] = FinallyTokenNode

class FloatNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for float."""
    pass

NODE_MAP['float'] = FloatNode

class ForTokenNode(TSNode, EditableMixin):
    """Generated node for for."""
    pass

NODE_MAP['for'] = ForTokenNode

class FromTokenNode(TSNode, EditableMixin):
    """Generated node for from."""
    pass

NODE_MAP['from'] = FromTokenNode

class GlobalTokenNode(TSNode, EditableMixin):
    """Generated node for global."""
    pass

NODE_MAP['global'] = GlobalTokenNode

class IdentifierNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for identifier."""
    pass

NODE_MAP['identifier'] = IdentifierNode

class IfTokenNode(TSNode, EditableMixin):
    """Generated node for if."""
    pass

NODE_MAP['if'] = IfTokenNode

class ImportTokenNode(TSNode, EditableMixin):
    """Generated node for import."""
    pass

NODE_MAP['import'] = ImportTokenNode

class InTokenNode(TSNode, EditableMixin):
    """Generated node for in."""
    pass

NODE_MAP['in'] = InTokenNode

class IntegerNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for integer."""
    pass

NODE_MAP['integer'] = IntegerNode

class IsTokenNode(TSNode, EditableMixin):
    """Generated node for is."""
    pass

NODE_MAP['is'] = IsTokenNode

class IsNotTokenNode(TSNode, EditableMixin):
    """Generated node for is not."""
    pass

NODE_MAP['is not'] = IsNotTokenNode

class LineContinuationNode(TSNode, EditableMixin):
    """Generated node for line_continuation."""
    pass

NODE_MAP['line_continuation'] = LineContinuationNode

class MatchTokenNode(TSNode, EditableMixin):
    """Generated node for match."""
    pass

NODE_MAP['match'] = MatchTokenNode

class NoneNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for none."""
    pass

NODE_MAP['none'] = NoneNode

class NonlocalTokenNode(TSNode, EditableMixin):
    """Generated node for nonlocal."""
    pass

NODE_MAP['nonlocal'] = NonlocalTokenNode

class NotTokenNode(TSNode, EditableMixin):
    """Generated node for not."""
    pass

NODE_MAP['not'] = NotTokenNode

class NotInTokenNode(TSNode, EditableMixin):
    """Generated node for not in."""
    pass

NODE_MAP['not in'] = NotInTokenNode

class OrTokenNode(TSNode, EditableMixin):
    """Generated node for or."""
    pass

NODE_MAP['or'] = OrTokenNode

class PassTokenNode(TSNode, EditableMixin):
    """Generated node for pass."""
    pass

NODE_MAP['pass'] = PassTokenNode

class PrintTokenNode(TSNode, EditableMixin):
    """Generated node for print."""
    pass

NODE_MAP['print'] = PrintTokenNode

class RaiseTokenNode(TSNode, EditableMixin):
    """Generated node for raise."""
    pass

NODE_MAP['raise'] = RaiseTokenNode

class ReturnTokenNode(TSNode, EditableMixin):
    """Generated node for return."""
    pass

NODE_MAP['return'] = ReturnTokenNode

class StringEndNode(TSNode, EditableMixin):
    """Generated node for string_end."""
    pass

NODE_MAP['string_end'] = StringEndNode

class StringStartNode(TSNode, EditableMixin):
    """Generated node for string_start."""
    pass

NODE_MAP['string_start'] = StringStartNode

class TrueNode(PrimaryExpressionNode, EditableMixin):
    """Generated node for true."""
    pass

NODE_MAP['true'] = TrueNode

class TryTokenNode(TSNode, EditableMixin):
    """Generated node for try."""
    pass

NODE_MAP['try'] = TryTokenNode

class TypeConversionNode(TSNode, EditableMixin):
    """Generated node for type_conversion."""
    pass

NODE_MAP['type_conversion'] = TypeConversionNode

class WhileTokenNode(TSNode, EditableMixin):
    """Generated node for while."""
    pass

NODE_MAP['while'] = WhileTokenNode

class WithTokenNode(TSNode, EditableMixin):
    """Generated node for with."""
    pass

NODE_MAP['with'] = WithTokenNode

class LeftBraceTokenNode(TSNode, EditableMixin):
    """Generated node for {."""
    pass

NODE_MAP['{'] = LeftBraceTokenNode

class PipeTokenNode(TSNode, EditableMixin):
    """Generated node for |."""
    pass

NODE_MAP['|'] = PipeTokenNode

class PipeEqualsTokenNode(TSNode, EditableMixin):
    """Generated node for |=."""
    pass

NODE_MAP['|='] = PipeEqualsTokenNode

class RightBraceTokenNode(TSNode, EditableMixin):
    """Generated node for }."""
    pass

NODE_MAP['}'] = RightBraceTokenNode

class TildeTokenNode(TSNode, EditableMixin):
    """Generated node for ~."""
    pass

NODE_MAP['~'] = TildeTokenNode

# Auto-register subclasses
TSNode.register_subclasses(NODE_MAP)